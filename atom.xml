<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://victoryfan.github.io</id>
    <title>哈拉少</title>
    <updated>2020-11-17T07:44:14.149Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://victoryfan.github.io"/>
    <link rel="self" href="https://victoryfan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://victoryfan.github.io/images/avatar.png</logo>
    <icon>https://victoryfan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 哈拉少</rights>
    <entry>
        <title type="html"><![CDATA[如何在Java代码中去掉烦人的“!=null”]]></title>
        <id>https://victoryfan.github.io/post/ru-he-zai-java-dai-ma-zhong-qu-diao-fan-ren-de-null/</id>
        <link href="https://victoryfan.github.io/post/ru-he-zai-java-dai-ma-zhong-qu-diao-fan-ren-de-null/">
        </link>
        <updated>2020-11-17T07:26:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p>为了避免空指针调用，我们经常会看到这样的语句：</p>
<pre><code>if (someobject != null) {
    someobject.doCalc();
}
</code></pre>
<p>最终，项目中会存在大量判空代码，多么丑陋繁冗！如何避免这种情况？我们是否滥用了判空呢？</p>
<h2 id="回答">回答</h2>
<p>这是初、中级程序猿经常会遇到的问题。他们总喜欢在方法中返回null，因此，在调用这些方法时，也不得不去判空。另外，也许受此习惯影响，他们总潜意识地认为，所有的返回都是不可信任的，为了保护自己程序，就加了大量的判空。</p>
<p>吐槽完毕，回到这个题目本身，进行判空前，请区分以下两种情况：</p>
<ul>
<li>null 是一个有效有意义的返回值(Where null is a valid response in terms of the contract; and)</li>
<li>null是无效有误的(Where it isn’t a valid response.)</li>
</ul>
<p>你可能还不明白这两句话的意思，不急，继续往下看，接下来将详细讨论这两种情况</p>
<h2 id="先说第2种情况">先说第2种情况</h2>
<p>null就是一个不合理的参数，就应该明确地中断程序，往外抛错误。这种情况常见于api方法。例如你开发了一个接口，id是一个必选的参数，如果调用方没传这个参数给你，当然不行。你要感知到这个情况，告诉调用方“嘿，哥们，你传个null给我做甚&quot;。</p>
<p>相对于判空语句，更好的检查方式有两个：</p>
<ul>
<li>assert语句，你可以把错误原因放到assert的参数中，这样不仅能保护你的程序不往下走，而且还能把错误原因返回给调用方，岂不是一举两得。</li>
<li>也可以直接抛出空指针异常。上面说了，此时null是个不合理的参数，有问题就是有问题，就应该大大方方往外抛。</li>
</ul>
<h2 id="第1种情况更复杂一些">第1种情况更复杂一些</h2>
<p>这种情况下，null是个”看上去“合理的值，例如，我查询数据库，某个查询条件下，就是没有对应值，此时null算是表达了“空”的概念。</p>
<p>这里给一些实践建议：</p>
<blockquote>
<p>假如方法的返回类型是collections，当返回结果是空时，你可以返回一个空的collections（empty list),而不要返回null.这样调用侧就能大胆地处理这个返回，例如调用侧拿到返回后，可以直接print list.size()，又无需担心空指针问题。（什么？想调用这个方法时，不记得之前实现该方法有没按照这个原则？所以说，代码习惯很重要！如果你养成习惯，都是这样写代码（返回空collections而不返回null)，你调用自己写的方法时，就能大胆地忽略判空）</p>
</blockquote>
<p><strong>返回类型不是collections，又怎么办呢？</strong><br>
那就返回一个空对象（而非null对象），下面举个“栗子”，假设有如下代码:</p>
<pre><code>public interface Action {
  void doSomething();}

public interface Parser {
  Action findAction(String userInput);}
</code></pre>
<p>其中，Parse有一个接口FindAction，这个接口会依据用户的输入，找到并执行对应的动作。假如用户输入不对，可能就找不到对应的动作（Action），因此findAction就会返回null，接下来action调用doSomething方法时，就会出现空指针。</p>
<p><strong>解决这个问题的一个方式，就是使用Null Object pattern（空对象模式）</strong><br>
我们来改造一下</p>
<p>类定义如下，这样定义findAction方法后，确保无论用户输入什么，都不会返回null对象：</p>
<pre><code>public class MyParser implements Parser {
  private static Action DO_NOTHING = new Action() {
    public void doSomething() { /* do nothing */ }
  };

  public Action findAction(String userInput) {
    // ...
    if ( /* we can't find any actions */ ) {
      return DO_NOTHING;
    }
  }
}
</code></pre>
<p>对比下面两份调用实例</p>
<p><strong>1、冗余: 每获取一个对象，就判一次空</strong></p>
<pre><code>Parser parser = ParserFactory.getParser();
if (parser == null) {
  // now what?
  // this would be an example of where null isn't (or shouldn't be) a valid response
}
Action action = parser.findAction(someInput);
if (action == null) {
  // do nothing} 
else {
  action.doSomething();
}
</code></pre>
<p><strong>2、精简</strong></p>
<pre><code>ParserFactory.getParser().findAction(someInput).doSomething();
</code></pre>
<p>因为无论什么情况，都不会返回空对象，因此通过findAction拿到action后，可以放心地调用action的方法。扩展一下：Java:如何更优雅的处理空值</p>
<p><strong>其他回答精选：</strong><br>
如果要用equal方法，请用object&lt;不可能为空&gt;.equal(object&lt;可能为空&gt;))</p>
<p>例如：</p>
<pre><code>&quot;bar&quot;.equals(foo)
</code></pre>
<p>而不是</p>
<pre><code>foo.equals(&quot;bar&quot;)
</code></pre>
<p>Java8或者guava lib中，提供了Optional类，这是一个元素容器，通过它来封装对象，可以减少判空。不过代码量还是不少。不爽。</p>
<p>如果你想返回null，请停下来想一想，这个地方是否更应该抛出一个异常。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BigDecimal一定不会丢失精度吗？]]></title>
        <id>https://victoryfan.github.io/post/bigdecimal-yi-ding-bu-hui-diu-shi-jing-du-ma/</id>
        <link href="https://victoryfan.github.io/post/bigdecimal-yi-ding-bu-hui-diu-shi-jing-du-ma/">
        </link>
        <updated>2020-11-17T06:20:32.000Z</updated>
        <content type="html"><![CDATA[<p>我们基本已经形成了常识，需要用到金钱的地方要用BigDecimal而不是其他，而我们也都知道浮点型变量在进行计算的时候会出现丢失精度的问题。</p>
<p>那么，你知道其实BigDecimal也会丢失精度吗？而使用BigDecimal的背后又有什么值得去探究的地方吗?</p>
<p>如下一段代码：</p>
<pre><code>System.out.println(0.05 + 0.01);  
System.out.println(1.0 - 0.42);  
System.out.println(4.015 * 100);  
System.out.println(123.3 / 100);  
</code></pre>
<p>输出：<br>
0.060000000000000005<br>
0.5800000000000001<br>
401.49999999999994<br>
1.2329999999999999</p>
<p>可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。</p>
<p>很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。</p>
<p>因为如上所示，他们两个的总和为0.060000000000000005。</p>
<p>这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。所以接下来我们就可以使用Java中的BigDecimal类来解决这类问题。</p>
<p><strong>普及一下：</strong><br>
Java中float的精度为6-7位有效数字。double的精度为15-16位。</p>
<p><strong>API</strong><br>
构造器：</p>
<pre><code>构造器                   描述
BigDecimal(int)       创建一个具有参数所指定整数值的对象。
BigDecimal(double)    创建一个具有参数所指定双精度值的对象。
BigDecimal(long)      创建一个具有参数所指定长整数值的对象。
BigDecimal(String)    创建一个具有参数所指定以字符串表示的数值的对象。
</code></pre>
<p>函数：</p>
<pre><code>方法                    描述
add(BigDecimal)       BigDecimal对象中的值相加，然后返回这个对象。
subtract(BigDecimal)  BigDecimal对象中的值相减，然后返回这个对象。
multiply(BigDecimal)  BigDecimal对象中的值相乘，然后返回这个对象。
divide(BigDecimal)    BigDecimal对象中的值相除，然后返回这个对象。
toString()            将BigDecimal对象的数值转换成字符串。
doubleValue()         将BigDecimal对象中的值以双精度数返回。
floatValue()          将BigDecimal对象中的值以单精度数返回。
longValue()           将BigDecimal对象中的值以长整数返回。
intValue()            将BigDecimal对象中的值以整数返回。
</code></pre>
<p>由于一般的数值类型，例如double不能准确的表示16位以上的数字。</p>
<p><strong>BigDecimal精度也丢失</strong><br>
我们在使用BigDecimal时，使用它的BigDecimal(String)构造器创建对象才有意义。其他的如BigDecimal b = new BigDecimal(1)这种，还是会发生精度丢失的问题。如下代码：</p>
<pre><code>BigDecimal a = new BigDecimal(1.01);
BigDecimal b = new BigDecimal(1.02);
BigDecimal c = new BigDecimal(&quot;1.01&quot;);
BigDecimal d = new BigDecimal(&quot;1.02&quot;);
System.out.println(a.add(b));
System.out.println(c.add(d));
</code></pre>
<p>输出：<br>
2.0300000000000000266453525910037569701671600341796875<br>
2.03</p>
<p>可见论丢失精度BigDecimal显的更为过分。但是使用Bigdecimal的BigDecimal(String)构造器的变量在进行运算的时候却没有出现这种问题。</p>
<p>究其原因计算机组成原理里面都有，它们的编码决定了这样的结果。</p>
<p>long可以准确存储19位数字，而double只能准备存储16位数字。</p>
<p>double由于有exp位，可以存16位以上的数字，但是需要以低位的不精确作为代价。如果需要高于19位数字的精确存储，则必须用BigInteger来保存，当然会牺牲一些性能。</p>
<p>所以我们一般使用BigDecimal来解决商业运算上丢失精度的问题的时候，<strong>声明BigDecimal对象的时候一定要使用它构造参数为String的类型的构造器。</strong></p>
<p>同时这个原则Effective Java和MySQL 必知必会中也都有提及。float和double只能用来做科学计算和工程计算。商业运算中我们要使用BigDecimal。</p>
<p>而且我们从源码的注释中官方也给出了说明，如下是BigDecimal类的double类型参数的构造器上的一部分注释说明：</p>
<pre><code>* The results of this constructor can be somewhat unpredictable.  
     * One might assume that writing {@codenew BigDecimal(0.1)} in  
     * Java creates a {@code BigDecimal} which is exactly equal to  
     * 0.1 (an unscaled value of 1, with a scale of 1), but it is  
     * actually equal to  
     * 0.1000000000000000055511151231257827021181583404541015625.  
     * This is because 0.1 cannot be represented exactly as a  
     * {@codedouble} (or, for that matter, as a binary fraction of  
     * any finite length).  Thus, the value that is being passed  
     * &lt;i&gt;in&lt;/i&gt; to the constructor is not exactly equal to 0.1,  
     * appearances notwithstanding.  
       ……  
        * When a {@codedouble} must be used as a source for a  
     * {@code BigDecimal}, note that this constructor provides an  
     * exact conversion; it does not give the same result as  
     * converting the {@codedouble} to a {@code String} using the  
     * {@link Double#toString(double)} method and then using the  
     * {@link #BigDecimal(String)} constructor.  To get that result,  
     * use the {@codestatic} {@link #valueOf(double)} method.  
     * &lt;/ol&gt;  
public BigDecimal(double val) {  
    this(val,MathContext.UNLIMITED);  
}  
</code></pre>
<p>第一段也说的很清楚它只能计算的无限接近这个数，但是无法精确到这个数。</p>
<p>第二段则说，如果要想准确计算这个值，那么需要把double类型的参数转化为String类型的。并且使用BigDecimal(String)这个构造方法进行构造。去获取结果。</p>
<p><strong>正确运用BigDecimal</strong><br>
另外，BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象，由刚才我们所罗列的API也可看出。</p>
<p>在一般开发过程中，我们数据库中存储的数据都是float和double类型的。在进行拿来拿去运算的时候还需要不断的转化，这样十分的不方便。这里我写了一个工具类：</p>
<pre><code>public class BigDecimalUtil {  

    private BigDecimalUtil() {  
    }  

    public static BigDecimal add(double v1, double v2) {// v1 + v2  
        BigDecimal b1 = new BigDecimal(Double.toString(v1));  
        BigDecimal b2 = new BigDecimal(Double.toString(v2));  
        return b1.add(b2);  
    }  

    public static BigDecimal sub(double v1, double v2) {  
        BigDecimal b1 = new BigDecimal(Double.toString(v1));  
        BigDecimal b2 = new BigDecimal(Double.toString(v2));  
        return b1.subtract(b2);  
    }  

    public static BigDecimal mul(double v1, double v2) {  
        BigDecimal b1 = new BigDecimal(Double.toString(v1));  
        BigDecimal b2 = new BigDecimal(Double.toString(v2));  
        return b1.multiply(b2);  
    }  

    public static BigDecimal div(double v1, double v2) {  
        BigDecimal b1 = new BigDecimal(Double.toString(v1));  
        BigDecimal b2 = new BigDecimal(Double.toString(v2));  
        // 2 = 保留小数点后两位   ROUND_HALF_UP = 四舍五入  
        return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);// 应对除不尽的情况  
    }  
}  
</code></pre>
<p>该工具类提供了double类型的基本的加减乘除运算。直接调用即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GET和POST两种基本请求方法有什么区别]]></title>
        <id>https://victoryfan.github.io/post/get-he-post-liang-chong-ji-ben-qing-qiu-fang-fa-you-shi-me-qu-bie/</id>
        <link href="https://victoryfan.github.io/post/get-he-post-liang-chong-ji-ben-qing-qiu-fang-fa-you-shi-me-qu-bie/">
        </link>
        <updated>2020-11-16T06:41:43.000Z</updated>
        <content type="html"><![CDATA[<p>GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。</p>
<p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</p>
<p>你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。</p>
<p>当你在面试中被问到这个问题，你的内心充满了自信和喜悦。<br>
<img src="https://victoryfan.github.io/post-images/1605508999150.jpg" alt="" loading="lazy"><br>
<strong>你轻轻松松的给出了一个“标准答案”：</strong></p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。<br>
（本标准答案参考自w3schools）</li>
</ul>
<p>“很遗憾，这不是我们要的回答”<br>
<img src="https://victoryfan.github.io/post-images/1605509156106.jpg" alt="" loading="lazy"></p>
<p>如果我告诉你GET和POST本质上没有区别你信吗？<br>
让我们扒下GET和POST的外衣，坦诚相见吧！<br>
<img src="https://victoryfan.github.io/post-images/1605509231198.jpeg" alt="" loading="lazy"></p>
<p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<p><strong>HTTP是什么？HTTP是基于TCP/IP的关于数据在万维网中如何通信的协议。</strong><br>
HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。<br>
<strong>那么，“标准答案”里的那些区别是怎么回事？</strong><br>
<img src="https://victoryfan.github.io/post-images/1605509461242.jpg" alt="" loading="lazy"><br>
在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。</p>
<p>但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。</p>
<p>HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。</p>
<p>如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。</p>
<p><strong>HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</strong><br>
但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？<br>
<img src="https://victoryfan.github.io/post-images/1605509671801.jpg" alt="" loading="lazy"></p>
<p>在我大万维网世界中，还有另一个重要的角色：运输公司。</p>
<p>不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。</p>
<p>但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。</p>
<p>如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>
<p><strong>好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</strong><br>
<img src="https://victoryfan.github.io/post-images/1605509829107.jpg" alt="" loading="lazy"></p>
<p><strong>真正的大BOSS还没出场呢。。。</strong></p>
<p>这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢...</p>
<p><strong>GET和POST还有一个重大区别：</strong><br>
<strong>简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></p>
<p>长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。</p>
<p><strong>JJ但这是一个坑！跳入需谨慎。为什么？</strong><br>
<img src="https://victoryfan.github.io/post-images/1605510312196.jpg" alt="" loading="lazy"></p>
<ol>
<li>GET与POST都有自己的语义，不能随便混用。</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li>
</ol>
<p>现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是开始装逼了？不过要小心被打<br>
<img src="https://victoryfan.github.io/post-images/1605510454726.jpeg" alt="" loading="lazy"></p>
<p>引自：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/D36Yj_OjTLc3QURVMaEtjA">https://mp.weixin.qq.com/s/D36Yj_OjTLc3QURVMaEtjA</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP三次四次握手]]></title>
        <id>https://victoryfan.github.io/post/tcp-san-ci-si-ci-wo-shou/</id>
        <link href="https://victoryfan.github.io/post/tcp-san-ci-si-ci-wo-shou/">
        </link>
        <updated>2020-11-11T07:21:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构">计算机网络体系结构</h2>
<p>在计算机网络的基本概念中，分层次的体系结构是最基本的。</p>
<p><strong>网络协议是什么？</strong><br>
在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答悉尼下。这些规则被称为网络协议。</p>
<h2 id="为什么要对网络协议分层">为什么要对网络协议分层？</h2>
<ul>
<li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li>
<li>灵活性好。当其中一层的技术发生变化，只要层间接口关系保持不变，其他层不受影响。</li>
<li>易于实现和维护。</li>
<li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li>
</ul>
<p><strong>网络协议分层的缺点：</strong> 功能可能出现在多个层里，产生了额外开销。<br>
为了使不同体系结构的计算机网络都能互联，国际标准化组织 ISO 于1977年提出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI/RM，简称为OSI。</p>
<p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用，TCP/IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP 是一个四层体系结构，它包含应用层，运输层，网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题），不过从实质上讲，TCP/IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚，有时为了方便，也可把最底下两层称为网络接口层。</p>
<p><strong>四层协议，五层协议和七层协议的关系如下：</strong></p>
<ul>
<li>TCP/IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。</li>
<li>五层协议的体系结构主要包括：应用层、运输层、网络层、数据链路层和物理层。</li>
<li>OSI七层协议模型主要包括：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li>
</ul>
<p><em>注：</em> 五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p>
<h2 id="tcpip协议族">TCP/IP协议族</h2>
<p><strong>应用层</strong><br>
应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<p><strong>运输层</strong><br>
运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</p>
<p><em><strong>运输层主要使用以下两种协议：</strong></em></p>
<ol>
<li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li>
<li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连续</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不实用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一、一对多、多对一和多对多交互通信</td>
<td>只能一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>场景</td>
<td>适用于实时应用（IP电话、视频电话、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
<p><strong>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</strong><br>
运行在TCP协议上的协议：</p>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。</li>
<li>FTP（File Transfer Protocol，文件传输协议），用于文件传输。</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p>运行在UDP协议上的协议：</p>
<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p>运行在TCP和UDP协议上：</p>
<ul>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。</li>
</ul>
<p><strong>网络层</strong><br>
网络层的任务就是选择合适的网间路由和交换节点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p>
<p><strong>数据链路层</strong><br>
数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p>
<p><em>一般的web应用的通信传输流是这样的：</em></p>
<figure data-type="image" tabindex="1"><img src="https://victoryfan.github.io/post-images/1605253512389.jpg" alt="" loading="lazy"></figure>
<p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</p>
<p><strong>物理层</strong><br>
在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p><strong>TCP/IP 协议族</strong><br>
在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。<br>
<img src="https://victoryfan.github.io/post-images/1605253717484.jpg" alt="" loading="lazy"></p>
<p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p>
<p><strong>重点：</strong><br>
TCP（传输控制协议）和IP（网际协议） 是最先定义的两个核心协议，所以才统称为TCP/IP协议族。</p>
<p><strong>TCP的三次握手四次挥手</strong><br>
TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。<strong>通过三次握手建立一个链接，通过四次挥手来关闭一个连接。</strong></p>
<p><strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</strong></p>
<p><strong>TCP报文的头部结构</strong><br>
在了解TCP连接之前先来了解一下TCP报文的头部结构。<br>
<img src="https://victoryfan.github.io/post-images/1605253987472.jpg" alt="" loading="lazy"></p>
<p>上图中有几个字段需要重点介绍下：<br>
（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>
（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。<br>
（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p>
<ul>
<li>ACK：确认序号有效。</li>
<li>FIN：释放一个连接。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>URG：紧急指针（urgent pointer）有效。</li>
</ul>
<p><em>注意：</em></p>
<ul>
<li>不要将确认序号ack与标志位中的ACK搞混了。</li>
<li>确认方ack=发起方seq+1，两端配对。</li>
</ul>
<p><strong>三次握手</strong><br>
三次握手的本质是确认通信双方收发数据的能力。</p>
<p>首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。</p>
<p>于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。</p>
<p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。</p>
<p>这，就是三次握手。<br>
<img src="https://victoryfan.github.io/post-images/1605255166259.jpg" alt="" loading="lazy"></p>
<ul>
<li>第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li>
<li>第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li>
<li>第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li>
</ul>
<p><strong>四次挥手</strong><br>
四次挥手的目的是关闭一个连接<br>
<img src="https://victoryfan.github.io/post-images/1605448184286.jpg" alt="" loading="lazy"></p>
<p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<ul>
<li>第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</li>
<li>第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</li>
<li>第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</li>
<li>第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li>
</ul>
<h2 id="常见面试题">常见面试题</h2>
<p><strong>为什么TCP连接的时候是3次？2次不可以吗？</strong><br>
因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p>
<p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p>
<p><strong>为什么TCP连接的时候是3次，关闭的时候却是4次？</strong><br>
因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p>
<p><strong>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</strong><br>
这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong><br>
TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10个冷门但实用的Docker实用技巧]]></title>
        <id>https://victoryfan.github.io/post/10-ge-leng-men-dan-shi-yong-de-docker-shi-yong-ji-qiao/</id>
        <link href="https://victoryfan.github.io/post/10-ge-leng-men-dan-shi-yong-de-docker-shi-yong-ji-qiao/">
        </link>
        <updated>2020-11-10T06:19:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-docker-top">1、docker top</h3>
<p>这个命令用来查看一个容器里面的进程信息，如：</p>
<pre><code>docker top int
UID   PID    PPID   C    STIME  TTY   TIME         CMD
root  21119  24419  99   Nov09   ?    1-00:21:33   /usr/local/bin/node ./src/client/host/startNode.js
root  24419  24390   0   Nov09   ?    00:00:00     node ./src/tool/startDPeer.js --main --rpchost 0.0.0.0 --rpcport 7001
</code></pre>
<h3 id="2-docker-load-docker-save">2、docker load &amp;&amp; docker save</h3>
<p>一般使用这两个命令去下载打包Kubernetes的镜像，因为国内的网速有些慢。</p>
<p>docker save 可以把一个镜像保存到 tar 文件中，如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker save node:8.12.0 &gt;node-8.12.0.tar
#同时 docker load 可以把镜像从 tar 文件导入到 docker 中
root@c02_walletnode_server_test_v_hk:~# docker load &lt; node-8.12.0.tar
</code></pre>
<h3 id="3-docker-search">3、docker search</h3>
<p>这个命令可以在命令行中方便的搜索 DockerHub 中的镜像，比如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker search nginx
NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
nginx                              Official build of Nginx.                        13988               [OK]
jwilder/nginx-proxy                Automated Nginx reverse proxy for docker con…   1908                                    [OK]
richarvey/nginx-php-fpm            Container running Nginx + PHP-FPM capable of…   791                                     [OK]
linuxserver/nginx                  An Nginx container, brought to you by LinuxS…   128
jc21/nginx-proxy-manager           Docker container for managing Nginx proxy ho…   109
tiangolo/nginx-rtmp                Docker image with Nginx using the nginx-rtmp…   103                                     [OK]
bitnami/nginx                      Bitnami nginx Docker Image                      90                                      [OK]
alfg/nginx-rtmp                    NGINX, nginx-rtmp-module and FFmpeg from sou…   80                                      [OK]
jlesage/nginx-proxy-manager        Docker container for Nginx Proxy Manager        67                                      [OK]
nginxdemos/hello                   NGINX webserver that serves a simple page co…   63                                      [OK]
nginx/nginx-ingress                NGINX Ingress Controller for Kubernetes         45
privatebin/nginx-fpm-alpine        PrivateBin running on an Nginx, php-fpm &amp; Al…   40                                      [OK]
nginxinc/nginx-unprivileged        Unprivileged NGINX Dockerfiles                  19
schmunk42/nginx-redirect           A very simple container to redirect HTTP tra…   19                                      [OK]
nginx/nginx-prometheus-exporter    NGINX Prometheus Exporter                       15
centos/nginx-112-centos7           Platform for running nginx 1.12 or building …   15
staticfloat/nginx-certbot          Opinionated setup for automatic TLS certs lo…   14                                      [OK]
raulr/nginx-wordpress              Nginx front-end for the official wordpress:f…   13                                      [OK]
centos/nginx-18-centos7            Platform for running nginx 1.8 or building n…   13
flashspys/nginx-static             Super Lightweight Nginx Image                   7                                       [OK]
bitwarden/nginx                    The Bitwarden nginx web server acting as a r…   7
mailu/nginx                        Mailu nginx frontend                            7                                       [OK]
bitnami/nginx-ingress-controller   Bitnami Docker Image for NGINX Ingress Contr…   6                                       [OK]
ansibleplaybookbundle/nginx-apb    An APB to deploy NGINX                          1                                       [OK]
wodby/nginx                        Generic nginx                                   1                                       [OK]
</code></pre>
<h3 id="4-docker-events">4、docker events</h3>
<p>获取 docker 的各种事件信息，比如创建了一个容器什么的。</p>
<pre><code>docker events
2020-07-28T21:28:46.000403018+08:00 image load sha256:432bf69f0427b52cad10897342eaf23521b7d973566354118e9a59c4d31b5fae (name=sha256:432bf69f0427b52cad10897342eaf23521b7d973566354118e9a59c4d31b5fae)
</code></pre>
<h3 id="5-docker-update">5、docker update</h3>
<p>当 docker run 了之后却发现里面有一些参数并不是你想要的状态比如你设置的 nginx 容器 cpu 或内存大小，这个时候你就可以使用 docker update 去修改这些参数。</p>
<pre><code>docker update nginx --cpus 2
</code></pre>
<h3 id="6-docker-history">6、docker history</h3>
<p>当你修改了一个镜像，但是忘记了每一层的修改命令，或者你想查看一个镜像是怎么构建的时候就可以使用这个命令，比如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker history int
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
1456ce379a71        38 hours ago        /bin/sh -c #(nop)  CMD [&quot;node&quot; &quot;./src/tool/s…   0B
286deaa63603        38 hours ago        /bin/sh -c #(nop)  EXPOSE 7001                  0B
037b119e344c        38 hours ago        /bin/sh -c #(nop) WORKDIR /home/nodeapp/int     0B
f690f91a1762        38 hours ago        /bin/sh -c cd /home/nodeapp/int &amp;&amp; npm insta…   39.3MB
6f8a531c291d        38 hours ago        /bin/sh -c mkdir -p /home/nodeapp/ &amp;&amp; cd /ho…   5.05MB
4e06a9fee726        38 hours ago        /bin/sh -c apt-get install git                  0B
ce426dead114        24 months ago       /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B
&lt;missing&gt;           24 months ago       /bin/sh -c set -ex   &amp;&amp; for key in     6A010…   4.5MB
&lt;missing&gt;           24 months ago       /bin/sh -c #(nop)  ENV YARN_VERSION=1.9.4       0B
&lt;missing&gt;           24 months ago       /bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg --print…   53.8MB
&lt;missing&gt;           24 months ago       /bin/sh -c #(nop)  ENV NODE_VERSION=8.12.0      0B
&lt;missing&gt;           24 months ago       /bin/sh -c set -ex   &amp;&amp; for key in     94AE3…   141kB
&lt;missing&gt;           24 months ago       /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   335kB
&lt;missing&gt;           24 months ago       /bin/sh -c set -ex;  apt-get update;  apt-ge…   320MB
&lt;missing&gt;           24 months ago       /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB
&lt;missing&gt;           24 months ago       /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B
&lt;missing&gt;           24 months ago       /bin/sh -c apt-get update &amp;&amp; apt-get install…   41.1MB
&lt;missing&gt;           24 months ago       /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B
&lt;missing&gt;           24 months ago       /bin/sh -c #(nop) ADD file:0b25d0012989e20b9…   127MB
</code></pre>
<h3 id="7-docker-wait">7、 docker wait</h3>
<p>这个命令可以查看容器的退出状态，比如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker wait int
137
</code></pre>
<h3 id="8-docker-pause-docker-unpause">8、docker pause &amp;&amp; docker unpause</h3>
<p>当你运行了一个容器但是想要暂停它运行的时候，就可以使用这个命令。</p>
<pre><code>docker pause int
docker unpause int
</code></pre>
<h3 id="9-docker-diff">9、docker diff</h3>
<p>当你运行了一个容器，但是你不知道容器里修改了哪一些文件的时候可以使用这个命令，比如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker diff int
C /home
C /home/nodeapp
C /home/nodeapp/int
C /home/nodeapp/int/data
C /home/nodeapp/int/data/intchain
A /home/nodeapp/int/data/intchain/.options.json
A /home/nodeapp/int/data/intchain/peerData
C /root
A /root/.bash_history
</code></pre>
<h3 id="10-docker-stats">10、docker stats</h3>
<p>这个是 docker 内置的监控命令，当你想查看当前主机下所有容器占用内存和 cpu 的情况的时候就可以使用这个命令。</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker stats

CONTAINER ID        NAME                           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
f278b86b9169        mocknet_stacks-node-follower   22.79%              65.09MiB / 62.91GiB   0.10%               6.73MB / 12MB       0B / 0B             4
25c4f5503d7d        mocknet_explorer               0.14%               68.5MiB / 62.91GiB    0.11%               1.52kB / 0B         0B / 0B             18
20fe840c19a5        mocknet_stacks-node-api        0.39%               98.35MiB / 62.91GiB   0.15%               14.7MB / 15.2MB     0B / 0B             22
d6e08253c502        mocknet_postgres               0.63%               21.96MiB / 62.91GiB   0.03%               12.2MB / 4.82MB     0B / 0B             8
bbc9c57ce680        mocknet_stacks-node-miner      1.10%               62.75MiB / 62.91GiB   0.10%               3.49MB / 3.72MB     0B / 0B             2
ebb3f75adc59        int                            91.52%              159.5MiB / 62.91GiB   0.25%               64.5MB / 2.78MB     0B / 0B             16
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法]]></title>
        <id>https://victoryfan.github.io/post/shu-ju-jie-gou-yu-suan-fa/</id>
        <link href="https://victoryfan.github.io/post/shu-ju-jie-gou-yu-suan-fa/">
        </link>
        <updated>2020-11-05T05:18:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-数据结构和算法概述">一、数据结构和算法概述</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://victoryfan.github.io/post/hello-gridea/</id>
        <link href="https://victoryfan.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>