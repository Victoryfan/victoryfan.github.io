<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://victoryfan.github.io</id>
    <title>哈拉少</title>
    <updated>2021-06-10T05:37:28.564Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://victoryfan.github.io"/>
    <link rel="self" href="https://victoryfan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://victoryfan.github.io/images/avatar.png</logo>
    <icon>https://victoryfan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 哈拉少</rights>
    <entry>
        <title type="html"><![CDATA[元宇宙]]></title>
        <id>https://victoryfan.github.io/post/yuan-yu-zhou/</id>
        <link href="https://victoryfan.github.io/post/yuan-yu-zhou/">
        </link>
        <updated>2021-06-10T05:31:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="元宇宙需要的属性">元宇宙需要的属性：</h2>
<p>身份：你拥有一个虚拟身份，无论与现实身份有没有相关性。</p>
<p>朋友：你在元宇宙当中拥有朋友，可以社交，无论在现实中是否认识。</p>
<p>沉浸感：你能够沉浸在元宇宙的体验中，忽略其他的一切。</p>
<p>低延迟：元宇宙中的一切都是同步发生的，没有异步性或延迟性。</p>
<p>多元化：元宇宙提供多种丰富内容，包括玩法、道具、美术素材等。</p>
<p>随意：你可以使用任何设备登陆元宇宙，随时随地沉浸其中。</p>
<p>经济系统：与任何复杂的大型游戏一样，元宇宙应该拥有自己的经济系统。</p>
<p>文明：元宇宙应该是一种虚拟文明。</p>
<p>你可以把他理解成游戏，也可以理解成虚拟现实，需要用到的技术是VR、区块链、边缘计算、人工智能等等，未来更多游戏公司应该会走向这条路（我觉得模拟城市可以率先搞起来）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[缓存理解]]></title>
        <id>https://victoryfan.github.io/post/huan-cun-li-jie/</id>
        <link href="https://victoryfan.github.io/post/huan-cun-li-jie/">
        </link>
        <updated>2020-12-11T09:24:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="本地缓存">本地缓存</h2>
<h3 id="1页面缓存">1.页面缓存</h3>
<p>我使用缓存的时间很早，2010年左右使用过 OSCache，当时主要用在 JSP 页面中用于实现页面级缓存。伪代码类似这样：</p>
<pre><code>&lt;cache:cache key=&quot;foobar&quot; scope=&quot;session&quot;&gt; 
      some jsp content 
&lt;/cache:cache&gt;
</code></pre>
<p>中间的那段 JSP 代码将会以 key=&quot;foobar&quot; 缓存在 session 中，这样其他页面就能共享这段缓存内容。在使用 JSP 这种远古技术的场景下，通过引入 OSCache 之后 ，页面的加载速度确实提升很快。<br>
但随着前后端分离以及分布式缓存的兴起，服务端的页面级缓存已经很少使用了。但是在前端领域，页面级缓存仍然很流行。</p>
<h3 id="2对象缓存">2.对象缓存</h3>
<p>2011年左右，开源中国的红薯哥写了很多篇关于缓存的文章。他提到：开源中国每天百万的动态请求，只用 1 台 4 Core 8G 的服务器就扛住了，得益于缓存框架 Ehcache。<br>
这让我非常神往，一个简单的框架竟能将单机性能做到如此这般，让我欲欲跃试。于是，我参考红薯哥的示例代码，在公司的余额提现服务上第一次使用了 Ehcache。<br>
逻辑也很简单，就是将成功或者失败状态的订单缓存起来，这样下次查询的时候，不用再查询支付宝服务了。伪代码类似这样：<br>
<img src="https://victoryfan.github.io/post-images/1607678917016.jpg" alt="" loading="lazy"><br>
添加缓存之后，优化的效果很明显 , 任务耗时从原来的40分钟减少到了5~10分钟。<br>
上面这个示例就是典型的「对象缓存」，它是本地缓存最常见的应用场景。相比页面缓存，它的粒度更细、更灵活，常用来缓存很少变化的数据，比如：全局配置、状态已完结的订单等，用于提升整体的查询速度。</p>
<h3 id="3刷新策略">3.刷新策略</h3>
<p>为了让客户端以最快的速度读取配置， 本地缓存使用了 Guava，整体架构如下图所示：<br>
<img src="https://victoryfan.github.io/post-images/1607679152787.jpg" alt="" loading="lazy"><br>
那本地缓存是如何更新的呢？有两种机制：</p>
<ul>
<li>客户端启动定时任务，从配置中心拉取数据。</li>
<li>当配置中心有数据变化时，主动推送给客户端。这里我并没有使用websocket，而是使用了 RocketMQ Remoting 通讯框架。</li>
</ul>
<p>后来我阅读了 Soul 网关的源码，它的本地缓存更新机制如下图所示，共支持 3 种策略：<br>
<img src="https://victoryfan.github.io/post-images/1607681098870.jpg" alt="" loading="lazy"></p>
<h4 id="zookeeper-watch-机制">zookeeper watch 机制</h4>
<p>soul-admin 在启动的时候，会将数据全量写入 zookeeper，后续数据发生变更时，会增量更新 zookeeper 的节点。与此同时，soul-web 会监听配置信息的节点，一旦有信息变更时，会更新本地缓存。</p>
<h4 id="websocket-机制">websocket 机制</h4>
<p>websocket 和 zookeeper 机制有点类似，当网关与 admin 首次建立好 websocket 连接时，admin 会推送一次全量数据，后续如果配置数据发生变更，则将增量数据通过 websocket 主动推送给 soul-web。</p>
<h4 id="http-长轮询机制">http 长轮询机制</h4>
<p>http请求到达服务端后，并不是马上响应，而是利用 Servlet 3.0 的异步机制响应数据。当配置发生变化时，服务端会挨个移除队列中的长轮询请求，告知是哪个 Group 的数据发生了变更，网关收到响应后，再次请求该 Group 的配置数据。不知道大家发现了没？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQL 查询效率优化原则]]></title>
        <id>https://victoryfan.github.io/post/sql-cha-xun-xiao-lu-you-hua-yuan-ze/</id>
        <link href="https://victoryfan.github.io/post/sql-cha-xun-xiao-lu-you-hua-yuan-ze/">
        </link>
        <updated>2020-11-27T10:14:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-对查询进行优化应尽可能避免全表扫描">1、对查询进行优化，应尽可能避免全表扫描</h3>
<p>首先应考虑在 where 及 order by 涉及的列上建立索引。<br>
下面我们来以一个表中177条数据比较一下,全表扫描与建立索引之后性能的一个比较。</p>
<h4 id="11-全表扫描">1.1 全表扫描</h4>
<figure data-type="image" tabindex="1"><img src="https://victoryfan.github.io/post-images/1606472458093.png" alt="" loading="lazy"></figure>
<h4 id="12-建立索引查询">1.2 建立索引查询</h4>
<figure data-type="image" tabindex="2"><img src="https://victoryfan.github.io/post-images/1606472570313.png" alt="" loading="lazy"></figure>
<h4 id="13-结论">1.3 结论</h4>
<p>从这两种方式查询数据库结果看,建立索引之后查询速度提高了些,现在数据量还不明显,如果表中有10万条速度,差异就会很明显了。</p>
<h3 id="2-写数据语句时尽可能减少表的全局扫描">2、写数据语句时尽可能减少表的全局扫描</h3>
<h4 id="21-减少where字段值null判断">2.1 减少where字段值null判断</h4>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status =null
</code></pre>
<p>如果这样做，就会导致引擎放弃使用索引而进行全表扫描。</p>
<p>应该进行如下的设置（即在没有值时，我们在存数据库时自动默认给个0值，而不是什么都不写）：</p>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status =0  
</code></pre>
<h4 id="22-应尽量避免在where子句中使用或操作符">2.2 应尽量避免在where子句中使用!=或&lt;&gt;操作符</h4>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status !=null;  
SELECT * FROM &quot;tb_real_time_car&quot; where pay_status &lt;&gt;null;
</code></pre>
<p>这样写将导致引擎放弃使用索引而进行全表扫描。</p>
<h4 id="23-应尽量避免在where子句中使用or来进行连接">2.3 应尽量避免在where子句中使用or来进行连接</h4>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status !=null or enter_time =null;
</code></pre>
<p>这样将导致引擎放弃使用索引而进行全表扫描。</p>
<p>可以这样操作：</p>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where pay_status !=null union all SELECT * FROM &quot;tb_real_time_car&quot; where enter_time =null;
</code></pre>
<h4 id="24-in-和-not-in-也要慎用">2.4 in 和 not in 也要慎用</h4>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed in[1,2,3,4];   
SELECT * FROM &quot;tb_real_time_car&quot; where rowed not in[1,2,3,4];
</code></pre>
<p>这样操作也会导致全表扫描。</p>
<p>可以这样写：</p>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed between 1 and 5;  
</code></pre>
<h4 id="25-少使用模糊匹配like">2.5 少使用模糊匹配like</h4>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where enter_time like '%2016-09-01%'
</code></pre>
<h4 id="26-应尽量避免在where子句中对字段进行表达式操作">2.6 应尽量避免在where子句中对字段进行表达式操作</h4>
<pre><code>SELECT * FROM &quot;tb_real_time_car &quot; where rowid/4=100;
</code></pre>
<h4 id="27-任何地方都不要使用-通配符去查询所有">2.7 任何地方都不要使用 * 通配符去查询所有</h4>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4=100;
</code></pre>
<p>以通配符*去查询所有数据，这样做也是非常耗时的，我们应该需要什么字段就查询什么字段。</p>
<p>应该这样做：</p>
<pre><code>SELECT leave_time FROM &quot;tb_real_time_car&quot; where rowid/4=100;
</code></pre>
<h3 id="3-不要在条件判断时进行算数运算">3、不要在条件判断时进行算数运算</h3>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowid/4=100;
</code></pre>
<h3 id="4-很多时候用-exists-代替-in-是一个好的选择">4、很多时候用 exists 代替 in 是一个好的选择</h3>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot; where rowed in (select rowed from&quot;tb_real&quot;);  
</code></pre>
<p>应该这样写：</p>
<pre><code>SELECT * FROM &quot;tb_real_time_car&quot;where exists (select rowed from&quot;tb_real&quot;where rowed = tb_real.rowid);
</code></pre>
<h3 id="5-论索引技巧">5、论索引技巧</h3>
<h4 id="51-并不是所有索引对查询都有效">5.1 并不是所有索引对查询都有效</h4>
<p>SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female 几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
<h4 id="52-索引并不是越多越好">5.2 索引并不是越多越好</h4>
<p>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
<h4 id="53-应尽可能的避免更新-clustered-聚合索引数据列">5.3 应尽可能的避免更新 clustered 聚合索引数据列</h4>
<p>因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<h4 id="54-尽量使用数字型字段">5.4 尽量使用数字型字段</h4>
<p>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<h3 id="6-创建数据库时应该注意">6、创建数据库时应该注意：</h3>
<h4 id="61-尽可能的使用-varcharnvarchar-代替-charnchar">6.1 尽可能的使用 varchar/nvarchar 代替 char/nchar</h4>
<p>因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<h4 id="62-用表变量来代替临时表">6.2 用表变量来代替临时表</h4>
<ul>
<li>如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</li>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</li>
<li>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
</ul>
<h4 id="63-尽量避免使用游标">6.3 尽量避免使用游标</h4>
<ul>
<li>因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</li>
<li>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li>
</ul>
<h3 id="7-数据放回时注意什么">7、数据放回时注意什么</h3>
<h4 id="71-尽量避免大事务操作提高系统并发能力">7.1  尽量避免大事务操作，提高系统并发能力</h4>
<p>这样可以有效提高系统的并发能力。</p>
<h4 id="72-尽量避免向客户端返回大数据量">7.2 尽量避免向客户端返回大数据量</h4>
<p>若数据量过大，应该考虑相应需求是否合理。</p>
<h3 id="8-总结">8、总结</h3>
<blockquote>
<p>1.尽量避免where中包含子查询；<br>
2.where条件中，过滤量最大的条件放在where子句最后；<br>
3.采用绑定变量有助于提高效率；<br>
4.在索引列上使用计算、改变索引列的类型、在索引列上使用 !=  <strong>将放弃索引</strong>；<br>
5.运算符效率：exists高于in高于or，（not exists高于not in）；（这里指出：in和or都是效率较低的运算，但是in的效率：O(logn)仍然比or的效率：O(n)高的多，尤其当运算列不是索引的时候尤为明显）；<br>
6.避免在索引列上使用 is null、is not null；<br>
7.使用索引的第一个列；<br>
8.用union-all替代union；<br>
9.like ‘text%’使用索引，但like ‘%text’不使用索引。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java:如何更优雅的处理空值？]]></title>
        <id>https://victoryfan.github.io/post/javaru-he-geng-you-ya-de-chu-li-kong-zhi/</id>
        <link href="https://victoryfan.github.io/post/javaru-he-geng-you-ya-de-chu-li-kong-zhi/">
        </link>
        <updated>2020-11-17T08:02:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="业务中的空值">业务中的空值</h2>
<h3 id="场景">场景</h3>
<p>存在一个UserSearchService用来提供用户查询的功能:</p>
<pre><code>public interface UserSearchService{
  List&lt;User&gt; listUser();

  User get(Integer id);
}
</code></pre>
<h4 id="问题现场">问题现场</h4>
<p>对于面向对象语言来讲，抽象层级特别的重要。尤其是对接口的抽象，它在设计和开发中占很大的比重，我们在开发时希望尽量面向接口编程。</p>
<p>于以上描述的接口方法来看，大概可以推断出可能它包含了以下两个含义:</p>
<ul>
<li>listUser(): 查询用户列表</li>
<li>get(Integer id): 查询单个用户</li>
</ul>
<p>在所有的开发中，XP推崇的TDD模式可以很好的引导我们对接口的定义，所以我们将TDD作为开发代码的”推动者”。</p>
<p>对于以上的接口，当我们使用TDD进行测试用例先行时，发现了潜在的问题：</p>
<ul>
<li>listUser() 如果没有数据，那它是返回空集合还是null呢？</li>
<li>get(Integer id) 如果没有这个对象，是抛异常还是返回null呢？</li>
</ul>
<h4 id="深入研究listuser">深入研究listUser</h4>
<p>我们先来讨论</p>
<pre><code>listUser()
</code></pre>
<p>这个接口，我经常看到如下实现:</p>
<pre><code>public List&lt;User&gt; listUser(){
    List&lt;User&gt; userList = userListRepostity.selectByExample(new UserExample());
    if(CollectionUtils.isEmpty(userList)){//spring util工具类
      return null;
    }
    return userList;
}
</code></pre>
<p>这段代码返回是null,从我多年的开发经验来讲，对于集合这样返回值，最好不要返回null，因为如果返回了null，会给调用者带来很多麻烦。你将会把这种调用风险交给调用者来控制。</p>
<p>如果调用者是一个谨慎的人，他会进行是否为null的条件判断。如果他并非谨慎，或者他是一个面向接口编程的狂热分子(当然，面向接口编程是正确的方向)，他会按照自己的理解去调用接口，而不进行是否为null的条件判断，如果这样的话，是非常危险的，它很有可能出现空指针异常！</p>
<p>根据墨菲定律来判断:<strong>“很有可能出现的问题，在将来一定会出现!”</strong></p>
<p>基于此，我们将它进行优化:</p>
<pre><code>public List&lt;User&gt; listUser(){
    List&lt;User&gt; userList = userListRepostity.selectByExample(new UserExample());
    if(CollectionUtils.isEmpty(userList)){
      return Lists.newArrayList();//guava类库提供的方式
    }
    return userList;
}
</code></pre>
<p>对于接口(List listUser())，它一定会返回List，即使没有数据，它仍然会返回List（集合中没有任何元素）;</p>
<p>通过以上的修改，我们成功的避免了有可能发生的空指针异常，这样的写法更安全！</p>
<h4 id="深入研究get方法">深入研究get方法</h4>
<p>对于接口</p>
<pre><code>User get(Integer id)
</code></pre>
<p>你能看到的现象是，我给出id，它一定会给我返回User.但事实真的很有可能不是这样的。</p>
<p>我看到过的实现:</p>
<pre><code>public User get(Integer id){
  return userRepository.selectByPrimaryKey(id);//从数据库中通过id直接获取实体对象
}
</code></pre>
<p>相信很多人也都会这样写。</p>
<p>通过代码的时候得知它的返回值很有可能是null! 但我们通过的接口是分辨不出来的!</p>
<p>这个是个非常危险的事情。尤其对于调用者来说！</p>
<p>我给出的建议是，需要在接口明明时补充文档,比如对于异常的说明,使用注解@exception:</p>
<pre><code>public interface UserSearchService{

  /**
   * 根据用户id获取用户信息
   * @param id 用户id
   * @return 用户实体
   * @exception UserNotFoundException
   */
  User get(Integer id);

}
</code></pre>
<p>我们把接口定义加上了说明之后，调用者会看到，如果调用此接口，很有可能抛出“UserNotFoundException(找不到用户)”这样的异常。</p>
<p>这种方式可以在调用者调用接口的时候看到接口的定义，但是，这种方式是”弱提示”的！</p>
<p>如果调用者忽略了注释，有可能就对业务系统产生了风险，这个风险有可能导致一个亿！</p>
<p><strong>除了以上这种”弱提示”的方式，还有一种方式是，返回值是有可能为空的。那要怎么办呢？</strong></p>
<p>我认为我们需要增加一个接口，用来描述这种场景。</p>
<p>引入jdk8的Optional,或者使用guava的Optional.看如下定义:</p>
<pre><code>public interface UserSearchService{

  /**
   * 根据用户id获取用户信息
   * @param id 用户id
   * @return 用户实体,此实体有可能是缺省值
   */
  Optional&lt;User&gt; getOptional(Integer id);
}
</code></pre>
<p><em>Optional有两个含义: 存在 or 缺省。</em></p>
<p>那么通过阅读接口getOptional()，我们可以很快的了解返回值的意图，这个其实是我们想看到的，它去除了二义性。</p>
<p>它的实现可以写成:</p>
<pre><code>public Optional&lt;User&gt; getOptional(Integer id){
  return Optional.ofNullable(userRepository.selectByPrimaryKey(id));
}
</code></pre>
<h4 id="深入入参">深入入参</h4>
<p>通过上述的所有接口的描述，你能确定入参id一定是必传的吗？我觉得答案应该是：不能确定。除非接口的文档注释上加以说明。</p>
<p><strong>那如何约束入参呢？</strong><br>
我给大家推荐两种方式：</p>
<ul>
<li>强制约束</li>
<li>文档性约束（弱提示）</li>
</ul>
<p><strong>1.强制约束，我们可以通过jsr 303进行严格的约束声明:</strong></p>
<pre><code>public interface UserSearchService{
  /**
   * 根据用户id获取用户信息
   * @param id 用户id
   * @return 用户实体
   * @exception UserNotFoundException
   */
  User get(@NotNull Integer id);

  /**
   * 根据用户id获取用户信息
   * @param id 用户id
   * @return 用户实体,此实体有可能是缺省值
   */
  Optional&lt;User&gt; getOptional(@NotNull Integer id);
}
</code></pre>
<p>当然，这样写，要配合AOP的操作进行验证，但让spring已经提供了很好的集成方案，在此我就不在赘述了。<br>
<strong>2.文档性约束</strong><br>
在很多时候，我们会遇到遗留代码，对于遗留代码，整体性改造的可能性很小。</p>
<p>我们更希望通过阅读接口的实现，来进行接口的说明。</p>
<p>jsr 305规范，给了我们一个描述接口入参的一个方式(需要引入库 com.google.code.findbugs:jsr305):</p>
<p>可以使用注解: @Nullable @Nonnull @CheckForNull 进行接口说明。比如:</p>
<pre><code>public interface UserSearchService{
  /**
   * 根据用户id获取用户信息
   * @param id 用户id
   * @return 用户实体
   * @exception UserNotFoundException
   */
  @CheckForNull
  User get(@NonNull Integer id);

  /**
   * 根据用户id获取用户信息
   * @param id 用户id
   * @return 用户实体,此实体有可能是缺省值
   */
  Optional&lt;User&gt; getOptional(@NonNull Integer id);
}
</code></pre>
<h4 id="小结">小结</h4>
<p>通过 空集合返回值,Optional,jsr 303，jsr 305这几种方式，可以让我们的代码可读性更强，出错率更低！</p>
<ul>
<li>空集合返回值 ：如果有集合这样返回值时，除非真的有说服自己的理由，否则，一定要返回空集合，而不是null。</li>
<li>Optional: 如果你的代码是jdk8，就引入它！如果不是，则使用Guava的Optional,或者升级jdk版本！它很大程度的能增加了接口的可读性！</li>
<li>jsr 303: 如果新的项目正在开发，不防加上这个试试！一定有一种特别爽的感觉!</li>
<li>jsr 305: 如果老的项目在你的手上，你可以尝试的加上这种文档型注解，有助于你后期的重构，或者新功能增加了，对于老接口的理解!</li>
</ul>
<h2 id="空对象模式">空对象模式</h2>
<h3 id="场景-2">场景</h3>
<p>我们来看一个DTO转化的场景，对象:</p>
<pre><code>@Data
static class PersonDTO{
  private String dtoName;
  private String dtoAge;
}

@Data
static class Person{
  private String name;
  private String age;
}
</code></pre>
<p>需求是将Person对象转化成PersonDTO，然后进行返回。</p>
<p>当然对于实际操作来讲，返回如果Person为空，将返回null,但是PersonDTO是不能返回null的（尤其Rest接口返回的这种DTO）。</p>
<p>在这里，我们只关注转化操作，看如下代码:</p>
<pre><code>@Test
public void shouldConvertDTO(){

  PersonDTO personDTO = new PersonDTO();

  Person person = new Person();
  if(!Objects.isNull(person)){
    personDTO.setDtoAge(person.getAge());
    personDTO.setDtoName(person.getName());
  }else{
    personDTO.setDtoAge(&quot;&quot;);
    personDTO.setDtoName(&quot;&quot;);
  }
}
</code></pre>
<h3 id="优化修改">优化修改</h3>
<p>这样的数据转化，我们认识可读性非常差，每个字段的判断，如果是空就设置为空字符串(“”)。</p>
<p>换一种思维方式进行思考，我们是拿到Person这个类的数据，然后进行赋值操作(setXXX),其实是不关系Person的具体实现是谁的。</p>
<p>那我们可以创建一个Person子类:</p>
<pre><code>static class NullPerson extends Person{
  @Override
  public String getAge() {
    return &quot;&quot;;
  }

  @Override
  public String getName() {
    return &quot;&quot;;
  }
}
</code></pre>
<p>它作为Person的一种特例而存在，如果当Person为空的时候，则返回一些get*的默认行为。</p>
<p>所以代码可以修改为:</p>
<pre><code>@Test
 public void shouldConvertDTO(){

   PersonDTO personDTO = new PersonDTO();

   Person person = getPerson();
   personDTO.setDtoAge(person.getAge());
   personDTO.setDtoName(person.getName());
 }

 private Person getPerson(){
   return new NullPerson();//如果Person是null ,则返回空对象
 }
</code></pre>
<p>其中getPerson()方法，可以用来根据业务逻辑获取Person有可能的对象（对当前例子来讲，如果Person不存在，返回Person的的特例NUllPerson），如果修改成这样，代码的可读性就会变的很强了。</p>
<h3 id="使用optional可以进行优化">使用Optional可以进行优化</h3>
<p>空对象模式，它的弊端在于需要创建一个特例对象，但是如果特例的情况比较多，我们是不是需要创建多个特例对象呢，虽然我们也使用了面向对象的多态特性，但是，业务的复杂性如果真的让我们创建多个特例对象，我们还是要再三考虑一下这种模式，它可能会带来代码的复杂性。</p>
<p>对于上述代码，还可以使用Optional进行优化。</p>
<pre><code>@Test
  public void shouldConvertDTO(){

    PersonDTO personDTO = new PersonDTO();

    Optional.ofNullable(getPerson()).ifPresent(person -&gt; {
      personDTO.setDtoAge(person.getAge());
      personDTO.setDtoName(person.getName());
    });
  }

  private Person getPerson(){
    return null;
  }
</code></pre>
<p>Optional对空值的使用，我觉得更为贴切，它只适用于”是否存在”的场景。</p>
<p>如果只对控制的存在判断，我建议使用Optional。</p>
<p><strong>Optioanl的正确使用</strong><br>
Optional如此强大，它表达了计算机最原始的特性(0 or 1)，那它如何正确的被使用呢？</p>
<h4 id="optional不要作为参数">Optional不要作为参数</h4>
<p>如果你写了一个public方法，这个方法规定了一些输入参数，这些参数中有一些是可以传入null的，那这时候是否可以使用Optional呢？<br>
<strong>一定不要这样使用!</strong></p>
<p>举个例子:</p>
<pre><code>public interface UserService{
  List&lt;User&gt; listUser(Optional&lt;String&gt; username);
}
</code></pre>
<p>这个例子的方法 listUser,可能在告诉我们需要根据username查询所有数据集合，如果username是空，也要返回所有的用户集合。</p>
<blockquote>
<p>“如果username是absent,是返回空集合吗？还是返回全部的用户数据集合？”</p>
</blockquote>
<p>Optioanl是一种分支的判断，那我们究竟是关注 Optional还是Optional.get()呢？</p>
<p><strong>我给大家的建议是，如果不想要这样的歧义，就不要使用它！</strong></p>
<p>如果你真的想表达两个含义，就給它拆分出两个接口:</p>
<pre><code>public interface UserService{
  List&lt;User&gt; listUser(String username);
  List&lt;User&gt; listUser();
}
</code></pre>
<p>我觉得这样的语义更强，并且更能满足 软件设计原则中的 “单一职责”。</p>
<p>如果你觉得你的入参真的有必要可能传null,那请使用jsr 303或者jsr 305进行说明和验证!</p>
<p><strong>请记住! Optional不能作为入参的参数!</strong></p>
<h4 id="optional作为返回值">Optional作为返回值</h4>
<h5 id="实体返回">实体返回</h5>
<p>那Optioanl可以做为返回值吗？</p>
<p>其实它是非常满足是否存在这个语义的。</p>
<p>如你要根据id获取用户信息，这个用户有可能存在或者不存在。</p>
<p>你可以这样使用:</p>
<pre><code>public interface UserService{
  Optional&lt;User&gt; get(Integer id);
}
</code></pre>
<p>当调用这个方法的时候，调用者很清楚get方法返回的数据，有可能不存在，这样可以做一些更合理的判断，更好的防止空指针的错误！</p>
<p>当然，如果业务方真的需要根据id必须查询出User的话，就不要这样使用了，请说明，你要抛出的异常。</p>
<p>只有当考虑它返回null是合理的情况下，才进行Optional的返回。</p>
<h5 id="集合实体返回">集合实体返回</h5>
<p>不是所有的返回值都可以这样用的！如果你返回的是集合：</p>
<pre><code>public interface UserService{
  Optional&lt;List&lt;User&gt;&gt; listUser();
}
</code></pre>
<p>这样的返回结果，会让调用者不知所措，是否我判断Optional之后，还用进行isEmpty的判断呢？</p>
<p>这样带来的返回值歧义！我认为是没有必要的。</p>
<p>我们要约定，对于List这种集合返回值，如果集合真的是null的，请返回空集合(Lists.newArrayList);</p>
<h4 id="使用optional变量">使用Optional变量</h4>
<pre><code>Optional&lt;User&gt; userOpt = ...
</code></pre>
<p>如果有这样的变量userOpt,请记住 ：</p>
<ul>
<li>一定不能直接使用get ，如果这样用，就丧失了Optional本身的含义 （ 比如userOp.get() ）。</li>
<li>不要直接使用getOrThrow ,如果你有这样的需求：获取不到就抛异常。那就要考虑，是否是调用的接口设计的是否合理。</li>
</ul>
<p><strong>getter中的使用</strong><br>
对于一个java bean,所有的属性都有可能返回null,那是否需要改写所有的getter成为Optional类型呢？<br>
<strong>不要这样滥用Optional</strong></p>
<p>即便 我java bean中的getter是符合Optional的，但是因为java bean 太多了，这样会导致你的代码有50%以上进行Optinal的判断，这样便污染了代码。(我想说，其实你的实体中的字段应该都是由业务含义的，会认真的思考过它存在的价值的，不能因为Optional的存在而滥用)</p>
<p>我们应该更关注于业务，而不只是空值的判断。</p>
<p>请不要在getter中滥用Optional。</p>
<h4 id="小结-2">小结</h4>
<p>可以这样总结Optional的使用：</p>
<ul>
<li>当使用值为空的情况，并非源于错误时，可以使用Optional!</li>
<li>Optional不要用于集合操作!</li>
<li>不要滥用Optional,比如在java bean的getter中!</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在Java代码中去掉烦人的“!=null”]]></title>
        <id>https://victoryfan.github.io/post/ru-he-zai-java-dai-ma-zhong-qu-diao-fan-ren-de-null/</id>
        <link href="https://victoryfan.github.io/post/ru-he-zai-java-dai-ma-zhong-qu-diao-fan-ren-de-null/">
        </link>
        <updated>2020-11-17T07:26:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p>为了避免空指针调用，我们经常会看到这样的语句：</p>
<pre><code>if (someobject != null) {
    someobject.doCalc();
}
</code></pre>
<p>最终，项目中会存在大量判空代码，多么丑陋繁冗！如何避免这种情况？我们是否滥用了判空呢？</p>
<h2 id="回答">回答</h2>
<p>这是初、中级程序猿经常会遇到的问题。他们总喜欢在方法中返回null，因此，在调用这些方法时，也不得不去判空。另外，也许受此习惯影响，他们总潜意识地认为，所有的返回都是不可信任的，为了保护自己程序，就加了大量的判空。</p>
<p>吐槽完毕，回到这个题目本身，进行判空前，请区分以下两种情况：</p>
<ul>
<li>null 是一个有效有意义的返回值(Where null is a valid response in terms of the contract; and)</li>
<li>null是无效有误的(Where it isn’t a valid response.)</li>
</ul>
<p>你可能还不明白这两句话的意思，不急，继续往下看，接下来将详细讨论这两种情况</p>
<h2 id="先说第2种情况">先说第2种情况</h2>
<p>null就是一个不合理的参数，就应该明确地中断程序，往外抛错误。这种情况常见于api方法。例如你开发了一个接口，id是一个必选的参数，如果调用方没传这个参数给你，当然不行。你要感知到这个情况，告诉调用方“嘿，哥们，你传个null给我做甚&quot;。</p>
<p>相对于判空语句，更好的检查方式有两个：</p>
<ul>
<li>assert语句，你可以把错误原因放到assert的参数中，这样不仅能保护你的程序不往下走，而且还能把错误原因返回给调用方，岂不是一举两得。</li>
<li>也可以直接抛出空指针异常。上面说了，此时null是个不合理的参数，有问题就是有问题，就应该大大方方往外抛。</li>
</ul>
<h2 id="第1种情况更复杂一些">第1种情况更复杂一些</h2>
<p>这种情况下，null是个”看上去“合理的值，例如，我查询数据库，某个查询条件下，就是没有对应值，此时null算是表达了“空”的概念。</p>
<p>这里给一些实践建议：</p>
<blockquote>
<p>假如方法的返回类型是collections，当返回结果是空时，你可以返回一个空的collections（empty list),而不要返回null.这样调用侧就能大胆地处理这个返回，例如调用侧拿到返回后，可以直接print list.size()，又无需担心空指针问题。（什么？想调用这个方法时，不记得之前实现该方法有没按照这个原则？所以说，代码习惯很重要！如果你养成习惯，都是这样写代码（返回空collections而不返回null)，你调用自己写的方法时，就能大胆地忽略判空）</p>
</blockquote>
<p><strong>返回类型不是collections，又怎么办呢？</strong><br>
那就返回一个空对象（而非null对象），下面举个“栗子”，假设有如下代码:</p>
<pre><code>public interface Action {
  void doSomething();}

public interface Parser {
  Action findAction(String userInput);}
</code></pre>
<p>其中，Parse有一个接口FindAction，这个接口会依据用户的输入，找到并执行对应的动作。假如用户输入不对，可能就找不到对应的动作（Action），因此findAction就会返回null，接下来action调用doSomething方法时，就会出现空指针。</p>
<p><strong>解决这个问题的一个方式，就是使用Null Object pattern（空对象模式）</strong><br>
我们来改造一下</p>
<p>类定义如下，这样定义findAction方法后，确保无论用户输入什么，都不会返回null对象：</p>
<pre><code>public class MyParser implements Parser {
  private static Action DO_NOTHING = new Action() {
    public void doSomething() { /* do nothing */ }
  };

  public Action findAction(String userInput) {
    // ...
    if ( /* we can't find any actions */ ) {
      return DO_NOTHING;
    }
  }
}
</code></pre>
<p>对比下面两份调用实例</p>
<p><strong>1、冗余: 每获取一个对象，就判一次空</strong></p>
<pre><code>Parser parser = ParserFactory.getParser();
if (parser == null) {
  // now what?
  // this would be an example of where null isn't (or shouldn't be) a valid response
}
Action action = parser.findAction(someInput);
if (action == null) {
  // do nothing} 
else {
  action.doSomething();
}
</code></pre>
<p><strong>2、精简</strong></p>
<pre><code>ParserFactory.getParser().findAction(someInput).doSomething();
</code></pre>
<p>因为无论什么情况，都不会返回空对象，因此通过findAction拿到action后，可以放心地调用action的方法。扩展一下：Java:如何更优雅的处理空值</p>
<p><strong>其他回答精选：</strong><br>
如果要用equal方法，请用object&lt;不可能为空&gt;.equal(object&lt;可能为空&gt;))</p>
<p>例如：</p>
<pre><code>&quot;bar&quot;.equals(foo)
</code></pre>
<p>而不是</p>
<pre><code>foo.equals(&quot;bar&quot;)
</code></pre>
<p><strong>原因如下例子：</strong></p>
<pre><code> public static void main(String[] args) {
        String g = null;
        System.out.println(&quot;1&quot;.equals(g));
        System.out.println(g.equals(&quot;1&quot;));
}

返回：  
false
Exception in thread &quot;main&quot; java.lang.NullPointerException
</code></pre>
<p>Java8或者guava lib中，提供了Optional类，这是一个元素容器，通过它来封装对象，可以减少判空。不过代码量还是不少。不爽。</p>
<p>如果你想返回null，请停下来想一想，这个地方是否更应该抛出一个异常。<br>
<img src="https://victoryfan.github.io/post-images/1605599736790.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BigDecimal一定不会丢失精度吗？]]></title>
        <id>https://victoryfan.github.io/post/bigdecimal-yi-ding-bu-hui-diu-shi-jing-du-ma/</id>
        <link href="https://victoryfan.github.io/post/bigdecimal-yi-ding-bu-hui-diu-shi-jing-du-ma/">
        </link>
        <updated>2020-11-17T06:20:32.000Z</updated>
        <content type="html"><![CDATA[<p>我们基本已经形成了常识，需要用到金钱的地方要用BigDecimal而不是其他，而我们也都知道浮点型变量在进行计算的时候会出现丢失精度的问题。</p>
<p>那么，你知道其实BigDecimal也会丢失精度吗？而使用BigDecimal的背后又有什么值得去探究的地方吗?</p>
<p>如下一段代码：</p>
<pre><code>System.out.println(0.05 + 0.01);  
System.out.println(1.0 - 0.42);  
System.out.println(4.015 * 100);  
System.out.println(123.3 / 100);  
</code></pre>
<p>输出：<br>
0.060000000000000005<br>
0.5800000000000001<br>
401.49999999999994<br>
1.2329999999999999</p>
<p>可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。</p>
<p>很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。</p>
<p>因为如上所示，他们两个的总和为0.060000000000000005。</p>
<p>这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。所以接下来我们就可以使用Java中的BigDecimal类来解决这类问题。</p>
<p><strong>普及一下：</strong><br>
Java中float的精度为6-7位有效数字。double的精度为15-16位。</p>
<p><strong>API</strong><br>
构造器：</p>
<pre><code>构造器                   描述
BigDecimal(int)       创建一个具有参数所指定整数值的对象。
BigDecimal(double)    创建一个具有参数所指定双精度值的对象。
BigDecimal(long)      创建一个具有参数所指定长整数值的对象。
BigDecimal(String)    创建一个具有参数所指定以字符串表示的数值的对象。
</code></pre>
<p>函数：</p>
<pre><code>方法                    描述
add(BigDecimal)       BigDecimal对象中的值相加，然后返回这个对象。
subtract(BigDecimal)  BigDecimal对象中的值相减，然后返回这个对象。
multiply(BigDecimal)  BigDecimal对象中的值相乘，然后返回这个对象。
divide(BigDecimal)    BigDecimal对象中的值相除，然后返回这个对象。
toString()            将BigDecimal对象的数值转换成字符串。
doubleValue()         将BigDecimal对象中的值以双精度数返回。
floatValue()          将BigDecimal对象中的值以单精度数返回。
longValue()           将BigDecimal对象中的值以长整数返回。
intValue()            将BigDecimal对象中的值以整数返回。
</code></pre>
<p>由于一般的数值类型，例如double不能准确的表示16位以上的数字。</p>
<p><strong>BigDecimal精度也丢失</strong><br>
我们在使用BigDecimal时，使用它的BigDecimal(String)构造器创建对象才有意义。其他的如BigDecimal b = new BigDecimal(1)这种，还是会发生精度丢失的问题。如下代码：</p>
<pre><code>BigDecimal a = new BigDecimal(1.01);
BigDecimal b = new BigDecimal(1.02);
BigDecimal c = new BigDecimal(&quot;1.01&quot;);
BigDecimal d = new BigDecimal(&quot;1.02&quot;);
System.out.println(a.add(b));
System.out.println(c.add(d));
</code></pre>
<p>输出：<br>
2.0300000000000000266453525910037569701671600341796875<br>
2.03</p>
<p>可见论丢失精度BigDecimal显的更为过分。但是使用Bigdecimal的BigDecimal(String)构造器的变量在进行运算的时候却没有出现这种问题。</p>
<p>究其原因计算机组成原理里面都有，它们的编码决定了这样的结果。</p>
<p>long可以准确存储19位数字，而double只能准备存储16位数字。</p>
<p>double由于有exp位，可以存16位以上的数字，但是需要以低位的不精确作为代价。如果需要高于19位数字的精确存储，则必须用BigInteger来保存，当然会牺牲一些性能。</p>
<p>所以我们一般使用BigDecimal来解决商业运算上丢失精度的问题的时候，<strong>声明BigDecimal对象的时候一定要使用它构造参数为String的类型的构造器。</strong></p>
<p>同时这个原则Effective Java和MySQL 必知必会中也都有提及。float和double只能用来做科学计算和工程计算。商业运算中我们要使用BigDecimal。</p>
<p>而且我们从源码的注释中官方也给出了说明，如下是BigDecimal类的double类型参数的构造器上的一部分注释说明：</p>
<pre><code>* The results of this constructor can be somewhat unpredictable.  
     * One might assume that writing {@codenew BigDecimal(0.1)} in  
     * Java creates a {@code BigDecimal} which is exactly equal to  
     * 0.1 (an unscaled value of 1, with a scale of 1), but it is  
     * actually equal to  
     * 0.1000000000000000055511151231257827021181583404541015625.  
     * This is because 0.1 cannot be represented exactly as a  
     * {@codedouble} (or, for that matter, as a binary fraction of  
     * any finite length).  Thus, the value that is being passed  
     * &lt;i&gt;in&lt;/i&gt; to the constructor is not exactly equal to 0.1,  
     * appearances notwithstanding.  
       ……  
        * When a {@codedouble} must be used as a source for a  
     * {@code BigDecimal}, note that this constructor provides an  
     * exact conversion; it does not give the same result as  
     * converting the {@codedouble} to a {@code String} using the  
     * {@link Double#toString(double)} method and then using the  
     * {@link #BigDecimal(String)} constructor.  To get that result,  
     * use the {@codestatic} {@link #valueOf(double)} method.  
     * &lt;/ol&gt;  
public BigDecimal(double val) {  
    this(val,MathContext.UNLIMITED);  
}  
</code></pre>
<p>第一段也说的很清楚它只能计算的无限接近这个数，但是无法精确到这个数。</p>
<p>第二段则说，如果要想准确计算这个值，那么需要把double类型的参数转化为String类型的。并且使用BigDecimal(String)这个构造方法进行构造。去获取结果。</p>
<p><strong>正确运用BigDecimal</strong><br>
另外，BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象，由刚才我们所罗列的API也可看出。</p>
<p>在一般开发过程中，我们数据库中存储的数据都是float和double类型的。在进行拿来拿去运算的时候还需要不断的转化，这样十分的不方便。这里我写了一个工具类：</p>
<pre><code>public class BigDecimalUtil {  

    private BigDecimalUtil() {  
    }  

    public static BigDecimal add(double v1, double v2) {// v1 + v2  
        BigDecimal b1 = new BigDecimal(Double.toString(v1));  
        BigDecimal b2 = new BigDecimal(Double.toString(v2));  
        return b1.add(b2);  
    }  

    public static BigDecimal sub(double v1, double v2) {  
        BigDecimal b1 = new BigDecimal(Double.toString(v1));  
        BigDecimal b2 = new BigDecimal(Double.toString(v2));  
        return b1.subtract(b2);  
    }  

    public static BigDecimal mul(double v1, double v2) {  
        BigDecimal b1 = new BigDecimal(Double.toString(v1));  
        BigDecimal b2 = new BigDecimal(Double.toString(v2));  
        return b1.multiply(b2);  
    }  

    public static BigDecimal div(double v1, double v2) {  
        BigDecimal b1 = new BigDecimal(Double.toString(v1));  
        BigDecimal b2 = new BigDecimal(Double.toString(v2));  
        // 2 = 保留小数点后两位   ROUND_HALF_UP = 四舍五入  
        return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);// 应对除不尽的情况  
    }  
}  
</code></pre>
<p>该工具类提供了double类型的基本的加减乘除运算。直接调用即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GET和POST两种基本请求方法有什么区别]]></title>
        <id>https://victoryfan.github.io/post/get-he-post-liang-chong-ji-ben-qing-qiu-fang-fa-you-shi-me-qu-bie/</id>
        <link href="https://victoryfan.github.io/post/get-he-post-liang-chong-ji-ben-qing-qiu-fang-fa-you-shi-me-qu-bie/">
        </link>
        <updated>2020-11-16T06:41:43.000Z</updated>
        <content type="html"><![CDATA[<p>GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。</p>
<p>最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。</p>
<p>你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。</p>
<p>当你在面试中被问到这个问题，你的内心充满了自信和喜悦。<br>
<img src="https://victoryfan.github.io/post-images/1605508999150.jpg" alt="" loading="lazy"><br>
<strong>你轻轻松松的给出了一个“标准答案”：</strong></p>
<ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>
<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中。<br>
（本标准答案参考自w3schools）</li>
</ul>
<p>“很遗憾，这不是我们要的回答”<br>
<img src="https://victoryfan.github.io/post-images/1605509156106.jpg" alt="" loading="lazy"></p>
<p>如果我告诉你GET和POST本质上没有区别你信吗？<br>
让我们扒下GET和POST的外衣，坦诚相见吧！<br>
<img src="https://victoryfan.github.io/post-images/1605509231198.jpeg" alt="" loading="lazy"></p>
<p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p>
<p><strong>HTTP是什么？HTTP是基于TCP/IP的关于数据在万维网中如何通信的协议。</strong><br>
HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。<br>
<strong>那么，“标准答案”里的那些区别是怎么回事？</strong><br>
<img src="https://victoryfan.github.io/post-images/1605509461242.jpg" alt="" loading="lazy"><br>
在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。</p>
<p>但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。</p>
<p>HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签（设置method为GET），而且要求把传送的数据放在车顶上（url中）以方便记录。</p>
<p>如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。</p>
<p><strong>HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。</strong><br>
但是，我们只看到HTTP对GET和POST参数的传送渠道（url还是requrest body）提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢？<br>
<img src="https://victoryfan.github.io/post-images/1605509671801.jpg" alt="" loading="lazy"></p>
<p>在我大万维网世界中，还有另一个重要的角色：运输公司。</p>
<p>不同的浏览器（发起http请求）和服务器（接受http请求）就是不同的运输公司。虽然理论上，你可以在车顶上无限的堆货物（url中无限加参数）。</p>
<p>但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。</p>
<p>如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。</p>
<p><strong>好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</strong><br>
<img src="https://victoryfan.github.io/post-images/1605509829107.jpg" alt="" loading="lazy"></p>
<p><strong>真正的大BOSS还没出场呢。。。</strong></p>
<p>这位BOSS有多神秘？当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢...</p>
<p><strong>GET和POST还有一个重大区别：</strong><br>
<strong>简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。</strong></p>
<p>长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p>
<p>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
<p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。</p>
<p><strong>JJ但这是一个坑！跳入需谨慎。为什么？</strong><br>
<img src="https://victoryfan.github.io/post-images/1605510312196.jpg" alt="" loading="lazy"></p>
<ol>
<li>GET与POST都有自己的语义，不能随便混用。</li>
<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>
<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li>
</ol>
<p>现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是开始装逼了？不过要小心被打<br>
<img src="https://victoryfan.github.io/post-images/1605510454726.jpeg" alt="" loading="lazy"></p>
<p>引自：</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/D36Yj_OjTLc3QURVMaEtjA">https://mp.weixin.qq.com/s/D36Yj_OjTLc3QURVMaEtjA</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TCP三次四次握手]]></title>
        <id>https://victoryfan.github.io/post/tcp-san-ci-si-ci-wo-shou/</id>
        <link href="https://victoryfan.github.io/post/tcp-san-ci-si-ci-wo-shou/">
        </link>
        <updated>2020-11-11T07:21:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="计算机网络体系结构">计算机网络体系结构</h2>
<p>在计算机网络的基本概念中，分层次的体系结构是最基本的。</p>
<p><strong>网络协议是什么？</strong><br>
在计算机网络要做到有条不紊地交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答悉尼下。这些规则被称为网络协议。</p>
<h2 id="为什么要对网络协议分层">为什么要对网络协议分层？</h2>
<ul>
<li>简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。</li>
<li>灵活性好。当其中一层的技术发生变化，只要层间接口关系保持不变，其他层不受影响。</li>
<li>易于实现和维护。</li>
<li>促进标准化工作。分开后，每层功能可以相对简单地被描述。</li>
</ul>
<p><strong>网络协议分层的缺点：</strong> 功能可能出现在多个层里，产生了额外开销。<br>
为了使不同体系结构的计算机网络都能互联，国际标准化组织 ISO 于1977年提出了一个试图使各种计算机在世界范围内互联成网的标准框架，即著名的开放系统互联基本参考模型 OSI/RM，简称为OSI。</p>
<p>OSI 的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用，TCP/IP 体系结构则不同，但它现在却得到了非常广泛的应用。TCP/IP 是一个四层体系结构，它包含应用层，运输层，网际层和网络接口层（用网际层这个名字是强调这一层是为了解决不同网络的互连问题），不过从实质上讲，TCP/IP 只有最上面的三层，因为最下面的网络接口层并没有什么具体内容，因此在学习计算机网络的原理时往往采用折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚，有时为了方便，也可把最底下两层称为网络接口层。</p>
<p><strong>四层协议，五层协议和七层协议的关系如下：</strong></p>
<ul>
<li>TCP/IP是一个四层的体系结构，主要包括：应用层、运输层、网际层和网络接口层。</li>
<li>五层协议的体系结构主要包括：应用层、运输层、网络层、数据链路层和物理层。</li>
<li>OSI七层协议模型主要包括：应用层（Application）、表示层（Presentation）、会话层（Session）、运输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li>
</ul>
<p><em>注：</em> 五层协议的体系结构只是为了介绍网络原理而设计的，实际应用还是 TCP/IP 四层体系结构。</p>
<h2 id="tcpip协议族">TCP/IP协议族</h2>
<p><strong>应用层</strong><br>
应用层( application-layer ）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<p>对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<p><strong>运输层</strong><br>
运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。</p>
<p><em><strong>运输层主要使用以下两种协议：</strong></em></p>
<ol>
<li>传输控制协议-TCP：提供面向连接的，可靠的数据传输服务。</li>
<li>用户数据协议-UDP：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连续</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不实用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一、一对多、多对一和多对多交互通信</td>
<td>只能一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>场景</td>
<td>适用于实时应用（IP电话、视频电话、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
<p><strong>每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一：</strong><br>
运行在TCP协议上的协议：</p>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。</li>
<li>HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。</li>
<li>FTP（File Transfer Protocol，文件传输协议），用于文件传输。</li>
<li>POP3（Post Office Protocol, version 3，邮局协议），收邮件用。</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。</li>
<li>TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。</li>
<li>SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。</li>
</ul>
<p>运行在UDP协议上的协议：</p>
<ul>
<li>BOOTP（Boot Protocol，启动协议），应用于无盘设备。</li>
<li>NTP（Network Time Protocol，网络时间协议），用于网络同步。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。</li>
</ul>
<p>运行在TCP和UDP协议上：</p>
<ul>
<li>DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。</li>
</ul>
<p><strong>网络层</strong><br>
网络层的任务就是选择合适的网间路由和交换节点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或 IP 层。</p>
<p><strong>数据链路层</strong><br>
数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
<p>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。</p>
<p><em>一般的web应用的通信传输流是这样的：</em></p>
<figure data-type="image" tabindex="1"><img src="https://victoryfan.github.io/post-images/1605253512389.jpg" alt="" loading="lazy"></figure>
<p>发送端在层与层之间传输数据时，每经过一层时会被打上一个该层所属的首部信息。反之，接收端在层与层之间传输数据时，每经过一层时会把对应的首部信息去除。</p>
<p><strong>物理层</strong><br>
在物理层上所传送的数据单位是比特。物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<p><strong>TCP/IP 协议族</strong><br>
在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定是单指 TCP 和 IP 这两个具体的协议，而往往是表示互联网所使用的整个 TCP/IP 协议族。<br>
<img src="https://victoryfan.github.io/post-images/1605253717484.jpg" alt="" loading="lazy"></p>
<p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通讯模型，以及一整个网络传输协议家族，为网际网络的基础通讯架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协定家族的两个核心协定：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。</p>
<p><strong>重点：</strong><br>
TCP（传输控制协议）和IP（网际协议） 是最先定义的两个核心协议，所以才统称为TCP/IP协议族。</p>
<p><strong>TCP的三次握手四次挥手</strong><br>
TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务端保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：连接、数据传输、退出（关闭）。<strong>通过三次握手建立一个链接，通过四次挥手来关闭一个连接。</strong></p>
<p><strong>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</strong></p>
<p><strong>TCP报文的头部结构</strong><br>
在了解TCP连接之前先来了解一下TCP报文的头部结构。<br>
<img src="https://victoryfan.github.io/post-images/1605253987472.jpg" alt="" loading="lazy"></p>
<p>上图中有几个字段需要重点介绍下：<br>
（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。<br>
（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。<br>
（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p>
<ul>
<li>ACK：确认序号有效。</li>
<li>FIN：释放一个连接。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>URG：紧急指针（urgent pointer）有效。</li>
</ul>
<p><em>注意：</em></p>
<ul>
<li>不要将确认序号ack与标志位中的ACK搞混了。</li>
<li>确认方ack=发起方seq+1，两端配对。</li>
</ul>
<p><strong>三次握手</strong><br>
三次握手的本质是确认通信双方收发数据的能力。</p>
<p>首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。</p>
<p>于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。</p>
<p>然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。</p>
<p>这，就是三次握手。<br>
<img src="https://victoryfan.github.io/post-images/1605255166259.jpg" alt="" loading="lazy"></p>
<ul>
<li>第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</li>
<li>第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</li>
<li>第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</li>
</ul>
<p><strong>四次挥手</strong><br>
四次挥手的目的是关闭一个连接<br>
<img src="https://victoryfan.github.io/post-images/1605448184286.jpg" alt="" loading="lazy"></p>
<p>比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<ul>
<li>第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</li>
<li>第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</li>
<li>第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</li>
<li>第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</li>
</ul>
<h2 id="常见面试题">常见面试题</h2>
<p><strong>为什么TCP连接的时候是3次？2次不可以吗？</strong><br>
因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。</p>
<p>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p>
<p><strong>为什么TCP连接的时候是3次，关闭的时候却是4次？</strong><br>
因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p>
<p><strong>为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？</strong><br>
这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p>
<p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong><br>
TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10个冷门但实用的Docker实用技巧]]></title>
        <id>https://victoryfan.github.io/post/10-ge-leng-men-dan-shi-yong-de-docker-shi-yong-ji-qiao/</id>
        <link href="https://victoryfan.github.io/post/10-ge-leng-men-dan-shi-yong-de-docker-shi-yong-ji-qiao/">
        </link>
        <updated>2020-11-10T06:19:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-docker-top">1、docker top</h3>
<p>这个命令用来查看一个容器里面的进程信息，如：</p>
<pre><code>docker top int
UID   PID    PPID   C    STIME  TTY   TIME         CMD
root  21119  24419  99   Nov09   ?    1-00:21:33   /usr/local/bin/node ./src/client/host/startNode.js
root  24419  24390   0   Nov09   ?    00:00:00     node ./src/tool/startDPeer.js --main --rpchost 0.0.0.0 --rpcport 7001
</code></pre>
<h3 id="2-docker-load-docker-save">2、docker load &amp;&amp; docker save</h3>
<p>一般使用这两个命令去下载打包Kubernetes的镜像，因为国内的网速有些慢。</p>
<p>docker save 可以把一个镜像保存到 tar 文件中，如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker save node:8.12.0 &gt;node-8.12.0.tar
#同时 docker load 可以把镜像从 tar 文件导入到 docker 中
root@c02_walletnode_server_test_v_hk:~# docker load &lt; node-8.12.0.tar
</code></pre>
<h3 id="3-docker-search">3、docker search</h3>
<p>这个命令可以在命令行中方便的搜索 DockerHub 中的镜像，比如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker search nginx
NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED
nginx                              Official build of Nginx.                        13988               [OK]
jwilder/nginx-proxy                Automated Nginx reverse proxy for docker con…   1908                                    [OK]
richarvey/nginx-php-fpm            Container running Nginx + PHP-FPM capable of…   791                                     [OK]
linuxserver/nginx                  An Nginx container, brought to you by LinuxS…   128
jc21/nginx-proxy-manager           Docker container for managing Nginx proxy ho…   109
tiangolo/nginx-rtmp                Docker image with Nginx using the nginx-rtmp…   103                                     [OK]
bitnami/nginx                      Bitnami nginx Docker Image                      90                                      [OK]
alfg/nginx-rtmp                    NGINX, nginx-rtmp-module and FFmpeg from sou…   80                                      [OK]
jlesage/nginx-proxy-manager        Docker container for Nginx Proxy Manager        67                                      [OK]
nginxdemos/hello                   NGINX webserver that serves a simple page co…   63                                      [OK]
nginx/nginx-ingress                NGINX Ingress Controller for Kubernetes         45
privatebin/nginx-fpm-alpine        PrivateBin running on an Nginx, php-fpm &amp; Al…   40                                      [OK]
nginxinc/nginx-unprivileged        Unprivileged NGINX Dockerfiles                  19
schmunk42/nginx-redirect           A very simple container to redirect HTTP tra…   19                                      [OK]
nginx/nginx-prometheus-exporter    NGINX Prometheus Exporter                       15
centos/nginx-112-centos7           Platform for running nginx 1.12 or building …   15
staticfloat/nginx-certbot          Opinionated setup for automatic TLS certs lo…   14                                      [OK]
raulr/nginx-wordpress              Nginx front-end for the official wordpress:f…   13                                      [OK]
centos/nginx-18-centos7            Platform for running nginx 1.8 or building n…   13
flashspys/nginx-static             Super Lightweight Nginx Image                   7                                       [OK]
bitwarden/nginx                    The Bitwarden nginx web server acting as a r…   7
mailu/nginx                        Mailu nginx frontend                            7                                       [OK]
bitnami/nginx-ingress-controller   Bitnami Docker Image for NGINX Ingress Contr…   6                                       [OK]
ansibleplaybookbundle/nginx-apb    An APB to deploy NGINX                          1                                       [OK]
wodby/nginx                        Generic nginx                                   1                                       [OK]
</code></pre>
<h3 id="4-docker-events">4、docker events</h3>
<p>获取 docker 的各种事件信息，比如创建了一个容器什么的。</p>
<pre><code>docker events
2020-07-28T21:28:46.000403018+08:00 image load sha256:432bf69f0427b52cad10897342eaf23521b7d973566354118e9a59c4d31b5fae (name=sha256:432bf69f0427b52cad10897342eaf23521b7d973566354118e9a59c4d31b5fae)
</code></pre>
<h3 id="5-docker-update">5、docker update</h3>
<p>当 docker run 了之后却发现里面有一些参数并不是你想要的状态比如你设置的 nginx 容器 cpu 或内存大小，这个时候你就可以使用 docker update 去修改这些参数。</p>
<pre><code>docker update nginx --cpus 2
</code></pre>
<h3 id="6-docker-history">6、docker history</h3>
<p>当你修改了一个镜像，但是忘记了每一层的修改命令，或者你想查看一个镜像是怎么构建的时候就可以使用这个命令，比如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker history int
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
1456ce379a71        38 hours ago        /bin/sh -c #(nop)  CMD [&quot;node&quot; &quot;./src/tool/s…   0B
286deaa63603        38 hours ago        /bin/sh -c #(nop)  EXPOSE 7001                  0B
037b119e344c        38 hours ago        /bin/sh -c #(nop) WORKDIR /home/nodeapp/int     0B
f690f91a1762        38 hours ago        /bin/sh -c cd /home/nodeapp/int &amp;&amp; npm insta…   39.3MB
6f8a531c291d        38 hours ago        /bin/sh -c mkdir -p /home/nodeapp/ &amp;&amp; cd /ho…   5.05MB
4e06a9fee726        38 hours ago        /bin/sh -c apt-get install git                  0B
ce426dead114        24 months ago       /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B
&lt;missing&gt;           24 months ago       /bin/sh -c set -ex   &amp;&amp; for key in     6A010…   4.5MB
&lt;missing&gt;           24 months ago       /bin/sh -c #(nop)  ENV YARN_VERSION=1.9.4       0B
&lt;missing&gt;           24 months ago       /bin/sh -c ARCH= &amp;&amp; dpkgArch=&quot;$(dpkg --print…   53.8MB
&lt;missing&gt;           24 months ago       /bin/sh -c #(nop)  ENV NODE_VERSION=8.12.0      0B
&lt;missing&gt;           24 months ago       /bin/sh -c set -ex   &amp;&amp; for key in     94AE3…   141kB
&lt;missing&gt;           24 months ago       /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   335kB
&lt;missing&gt;           24 months ago       /bin/sh -c set -ex;  apt-get update;  apt-ge…   320MB
&lt;missing&gt;           24 months ago       /bin/sh -c apt-get update &amp;&amp; apt-get install…   123MB
&lt;missing&gt;           24 months ago       /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   0B
&lt;missing&gt;           24 months ago       /bin/sh -c apt-get update &amp;&amp; apt-get install…   41.1MB
&lt;missing&gt;           24 months ago       /bin/sh -c #(nop)  CMD [&quot;bash&quot;]                 0B
&lt;missing&gt;           24 months ago       /bin/sh -c #(nop) ADD file:0b25d0012989e20b9…   127MB
</code></pre>
<h3 id="7-docker-wait">7、 docker wait</h3>
<p>这个命令可以查看容器的退出状态，比如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker wait int
137
</code></pre>
<h3 id="8-docker-pause-docker-unpause">8、docker pause &amp;&amp; docker unpause</h3>
<p>当你运行了一个容器但是想要暂停它运行的时候，就可以使用这个命令。</p>
<pre><code>docker pause int
docker unpause int
</code></pre>
<h3 id="9-docker-diff">9、docker diff</h3>
<p>当你运行了一个容器，但是你不知道容器里修改了哪一些文件的时候可以使用这个命令，比如：</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker diff int
C /home
C /home/nodeapp
C /home/nodeapp/int
C /home/nodeapp/int/data
C /home/nodeapp/int/data/intchain
A /home/nodeapp/int/data/intchain/.options.json
A /home/nodeapp/int/data/intchain/peerData
C /root
A /root/.bash_history
</code></pre>
<h3 id="10-docker-stats">10、docker stats</h3>
<p>这个是 docker 内置的监控命令，当你想查看当前主机下所有容器占用内存和 cpu 的情况的时候就可以使用这个命令。</p>
<pre><code>root@c02_walletnode_server_test_v_hk:~# docker stats

CONTAINER ID        NAME                           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS
f278b86b9169        mocknet_stacks-node-follower   22.79%              65.09MiB / 62.91GiB   0.10%               6.73MB / 12MB       0B / 0B             4
25c4f5503d7d        mocknet_explorer               0.14%               68.5MiB / 62.91GiB    0.11%               1.52kB / 0B         0B / 0B             18
20fe840c19a5        mocknet_stacks-node-api        0.39%               98.35MiB / 62.91GiB   0.15%               14.7MB / 15.2MB     0B / 0B             22
d6e08253c502        mocknet_postgres               0.63%               21.96MiB / 62.91GiB   0.03%               12.2MB / 4.82MB     0B / 0B             8
bbc9c57ce680        mocknet_stacks-node-miner      1.10%               62.75MiB / 62.91GiB   0.10%               3.49MB / 3.72MB     0B / 0B             2
ebb3f75adc59        int                            91.52%              159.5MiB / 62.91GiB   0.25%               64.5MB / 2.78MB     0B / 0B             16
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构与算法]]></title>
        <id>https://victoryfan.github.io/post/shu-ju-jie-gou-yu-suan-fa/</id>
        <link href="https://victoryfan.github.io/post/shu-ju-jie-gou-yu-suan-fa/">
        </link>
        <updated>2020-11-05T05:18:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-数据结构和算法概述">一、数据结构和算法概述</h1>
]]></content>
    </entry>
</feed>